<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UNO Game With Images</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    .card-img {
      /* Enforce small, consistent size for all displayed cards */
      width: 70px;
      height: 100px;
      /* Scales the 1024x1524 image down to fit, ensuring it covers the area */ 
      box-shadow: 0 0 4px rgba(0,0,0,0.6);
      transition: transform 0.12s;
    }
    .card-img:hover {
      transform: scale(1.08);
      cursor: pointer;
    }
    body {
      background: #121212;
    }
    /* New style for the game-over overlay button */
    #playAgainBtn {
        transition: transform 0.2s;
    }
    #playAgainBtn:hover {
        transform: scale(1.05);
    }
    /* Style for the color selection popup */
    #colorSelector {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #333;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0,0,0,0.8);
        z-index: 1000;
        text-align: center;
    }
    .color-option {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        margin: 5px;
        cursor: pointer;
        border: 4px solid transparent;
        transition: border-color 0.1s;
    }
    .color-option:hover {
        border-color: white;
    }
  </style>
</head>

<body class="text-white p-6">

  <audio id="wonder-theme" loop src="./soundtrack/wonder.mp3"></audio>
  <audio id="voyage-theme" loop src="./soundtrack/voyage.mp3"></audio>
  <audio id="relax-theme" loop src="./soundtrack/relax.mp3"></audio>
  <audio id="tense-theme" loop src="./soundtrack/tense.mp3"></audio>

  <audio id="win-sound" src="./SFX/VICTORY.mp3"></audio>
  <audio id="lose-sound" src="./SFX/LOST.mp3"></audio>
  <audio id="start-sound" src="./SFX/CHALLENGE.mp3"></audio>
  
  <audio id="play-card-sound" src="./SFX/PLACECARD.mp3"></audio>
  <audio id="draw-card-sound" src="./SFX/CARDSWOOSH.mp3"></audio>
  <audio id="plus-two-sound" src="./SFX/PLUS2.mp3"></audio> 
  <audio id="wild-sound" src="./SFX/CARDSWOOSH.mp3"></audio> 

  <button id="musicToggleBtn"
    class="fixed bottom-4 right-4 bg-gray-600 hover:bg-gray-700 p-2 rounded-full z-50 text-white font-bold shadow-lg">
    ðŸ”‡ Music
  </button>
  <h1 class="text-center text-4xl font-bold mb-6">UNO Game</h1>

  <div class="max-w-4xl mx-auto space-y-6">

    <div class="p-4 bg-gray-800 rounded">
      <h2 class="text-xl font-semibold mb-2">Computer's Cards</h2>
      <div id="computerHand" class="flex flex-wrap gap-3"></div>
    </div>

    <div class="p-4 bg-gray-800 rounded text-center">
      <h2 class="text-xl font-semibold">Top Card</h2>
      <div id="topCard" class="mt-3 flex justify-center"></div>
    </div>

    <div class="p-4 bg-gray-800 rounded">
      <h2 class="text-xl font-semibold mb-2">Your Hand</h2>
      <div id="playerHand" class="flex flex-wrap gap-3"></div>
      <button id="drawBtn"
        class="mt-4 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded font-semibold">
        Draw Card
      </button>
    </div>

    <div class="text-center">
      <a href="index.html" class="text-blue-400 underline text-lg">Return to Menu</a>
    </div>

    <div id="message" class="text-center text-xl font-bold mt-3"></div>

  </div>

<div id="colorSelector" class="hidden">
    <h3 class="text-xl font-bold mb-4">Choose a New Color</h3>
    <div id="colorOptions" class="flex justify-center space-x-2">
        <div class="color-option bg-red-600" onclick="handleColorSelect('red')"></div>
        <div class="color-option bg-green-600" onclick="handleColorSelect('green')"></div>
        <div class="color-option bg-blue-600" onclick="handleColorSelect('blue')"></div>
        <div class="color-option bg-yellow-400" onclick="handleColorSelect('yellow')"></div>
    </div>
</div>
<script>
/* ------------------------------------
      UNO GAME LOGIC (WITH IMAGES)
------------------------------------- */

// Define the core types of cards
const COLORS = ["red", "green", "blue", "yellow"];
const NUMBER_VALUES = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// --- MODIFIED ACTION VALUES TO INCLUDE WILDS ---
const ACTION_VALUES = ["+2", "miss", "wild", "+4"]; 
// --- NEW CONSTANT FOR WILDS ---
const WILD_VALUES = ["wild", "+4"];

// --- UPDATED CARD BACK PATH ---
const CARD_BACK_IMAGE_PATH = "cards/card_back.png"; 

let deck = [];
let playerHand = [];
let computerHand = [];
let topCard = null;

// --- STATE VARIABLES ---
let plusTwoActive = false; 
let skipActive = false; 
let gameOver = false; 
// --- NEW: Stores the index of the card waiting for color selection ---
let pendingPlayIndex = -1; 
// --- NEW: Tracks the current color (only relevant for Wild/Wild+4) ---
let currentColor = null;

/* -------------------------------------
  1. Generate Deck using Naming Convention (MODIFIED)
------------------------------------- */

function generateDeck() {
  deck = [];
  
  COLORS.forEach(color => {
    // 1. NUMBER CARDS (0-9)
    NUMBER_VALUES.forEach(value => {
      const fileName = `${color}_${value}.png`;
      const imagePath = `cards/${fileName}`;
      
      const card = { color, value: value.toString(), image: imagePath, type: 'number' };
      
      deck.push(card); 

      if (value !== 0) {
        deck.push(card); 
      }
    });

    // 2. ACTION CARDS (+2 and miss)
    // Filter out wild cards since they are not color-specific initially
    ACTION_VALUES.filter(v => !WILD_VALUES.includes(v)).forEach(value => {
      const fileName = `${color}_${value}.png`;
      const imagePath = `cards/${fileName}`;
      
      const card = { color, value, image: imagePath, type: 'action' };
      deck.push(card); 
      deck.push(card); 
    });
  });

  // 3. WILD CARDS (4 of each) --- ADDED FOR WILDS ---
  WILD_VALUES.forEach(value => {
      const fileName = value === "wild" ? "wildcard_1.png" : "card_+4_1.png";
      const imagePath = `cards/${fileName}`;

      // Wild cards are generated without a color. The color property will be set
      // dynamically when played. We use a placeholder 'black' color.
      const card = { color: 'black', value, image: imagePath, type: 'wild' }; 
      
      // Add 4 of each Wild card type
      for(let i = 0; i < 4; i++) {
          deck.push({...card, isWild: true}); // Add a helper property
      }
  });

  console.log(`Generated ${deck.length} cards...`);
  
  deck = deck.sort(() => Math.random() - 0.5);
}

/* -------------------------------------
  2. Image Rendering Function
------------------------------------- */

function getCardImagePath(card, isFaceUp = true) {
  if (isFaceUp && card) {
    return card.image;
  } else {
    return CARD_BACK_IMAGE_PATH;
  }
}

/* Draw card */
function drawCard(hand) {
  if (deck.length === 0) {
    // Basic reshuffle of played cards (not fully implemented, but covers empty deck)
    generateDeck(); 
  }
  const drawnCard = deck.pop();
  if (drawnCard) {
      hand.push(drawnCard);
  }
}

/* -------------------------------------
  3. Render Function (MODIFIED)
------------------------------------- */

function render() {
  // Top Card
  const top = document.getElementById("topCard");
  top.innerHTML = "";
  if (topCard) {
    const topImg = document.createElement("img");
    topImg.src = getCardImagePath(topCard, true); 
    topImg.className = "card-img";
    
    // --- MODIFIED: Show the actual current color on the UI ---
    const displayColor = topCard.isWild && currentColor ? currentColor : topCard.color;
    topImg.alt = `Top Card: ${displayColor} ${topCard.value}`;

    // Add a color border to signify the current color after a Wild card play
    if (topCard.isWild && currentColor) {
        topImg.style.border = `4px solid ${currentColor === 'yellow' ? 'gold' : currentColor}`;
    } else {
        topImg.style.border = 'none';
    }
    // --------------------------------------------------------

    top.appendChild(topImg);
  }


  // Player Hand
  const handDiv = document.getElementById("playerHand");
  handDiv.innerHTML = "";
  playerHand.forEach((card, index) => {
    const img = document.createElement("img");
    img.src = getCardImagePath(card, true); 
    img.className = "card-img";
    
    // Only allow clicking if the game is not over AND color selector is not visible
    if (!gameOver && pendingPlayIndex === -1) {
        img.onclick = () => playCard(index);
    }
    
    img.alt = `${card.color} ${card.value}`; 
    handDiv.appendChild(img);
  });

  // Computer Hand â€” card backs only
  const compDiv = document.getElementById("computerHand");
  compDiv.innerHTML = "";
  computerHand.forEach(() => {
    const img = document.createElement("img");
    img.src = CARD_BACK_IMAGE_PATH; 
    img.className = "card-img";
    img.alt = "Card Back";
    compDiv.appendChild(img);
  });
}

/* Check if card playable (MODIFIED) */
function canPlay(card) {
    // --- ADDED/MODIFIED FOR WILD CARDS ---
    if (card.isWild) {
        return true; // Wild cards can be played anytime
    }
    // Get the effective color for the top card (the color set by a previous wild)
    const effectiveTopColor = topCard.isWild && currentColor ? currentColor : topCard.color;

    // Can play if color OR value match
    return card.color === effectiveTopColor || card.value === topCard.value;
    // ------------------------------------
}

/* -------------------------------------
  4. Action Card Logic Helpers (MODIFIED)
------------------------------------- */

function applyPlusTwoEffect(targetHand, targetName) {
    if (gameOver) return;

    drawCard(targetHand);
    drawCard(targetHand);
    
    plusTwoActive = false; // Penalty applied
    
    setMessage(`ðŸ’€ ${targetName} draws 2 cards and skips turn!`);
    render();
    
    if (targetName === "You") {
        setTimeout(computerTurn, 1000); 
    } else {
        setTimeout(() => {
            setMessage("Your turn now!");
        }, 1000); 
    }
}

// --- NEW FUNCTION FOR +4 EFFECT ---
function applyPlusFourEffect(targetHand, targetName) {
    if (gameOver) return;

    for (let i = 0; i < 4; i++) {
        drawCard(targetHand);
    }
    
    plusTwoActive = false; // Using the same flag for turn skip for simplicity
    
    setMessage(`ðŸ’€ ${targetName} draws 4 cards and skips turn! New Color: ${currentColor.toUpperCase()}`);
    render();
    
    if (targetName === "You") {
        setTimeout(computerTurn, 1000); 
    } else {
        setTimeout(() => {
            setMessage("Your turn now!");
        }, 1000); 
    }
}
// -----------------------------------

function applySkipEffect(targetName) {
    if (gameOver) return;

    skipActive = false; // Penalty applied
    
    setMessage(`â© ${targetName}'s turn is skipped!`);
    render();
    
    if (targetName === "You") {
        setTimeout(computerTurn, 1000); 
    } else {
        setTimeout(() => {
            setMessage("Your turn now!");
        }, 1000); 
    }
}

/* Player plays card (MODIFIED) */
function playCard(index) {
  if (gameOver || pendingPlayIndex !== -1) return;

  const card = playerHand[index];

  if (!canPlay(card)) {
    setMessage("âŒ You can't play that card!");
    return;
  }
  
  // --- ADDED/MODIFIED FOR WILD CARDS ---
  if (card.isWild) {
      pendingPlayIndex = index; // Store the card's index
      showColorSelector(); 
      playCardSound(); // Play sound immediately for feedback
      return; // Wait for color selection
  }
  // ------------------------------------
  
  // Normal card play logic
  topCard = card;
  currentColor = card.color; // Set/Reset the current color
  playerHand.splice(index, 1);
  
  playCardSound();
  
  setMessage("You played a card. Computer's turn...");
  render();

  if (checkWinner()) return;

  // APPLY ACTION EFFECT 
  if (card.value === "+2") {
    plusTwoActive = true; 
    playPlusTwoSound(); 
    setMessage(`You played a +2. Computer must draw 2!`);
  } else if (card.value === "miss") {
    skipActive = true;
    setMessage(`You played a Skip. Computer's turn is skipped!`);
  }
  
  setTimeout(computerTurn, 900);
}

// --- NEW: Color Selection Logic for Wild Cards ---
function showColorSelector() {
    document.getElementById("colorSelector").classList.remove('hidden');
    // Disable main draw button while color selector is active
    document.getElementById("drawBtn").disabled = true;
}

function hideColorSelector() {
    document.getElementById("colorSelector").classList.add('hidden');
    document.getElementById("drawBtn").disabled = false;
    pendingPlayIndex = -1;
}

window.handleColorSelect = function(selectedColor) {
    if (pendingPlayIndex === -1) return;
    
    const card = playerHand[pendingPlayIndex];
    
    // 1. Set the top card and current color
    topCard = card;
    currentColor = selectedColor; // This is the crucial step
    
    // 2. Remove the card from the player's hand
    playerHand.splice(pendingPlayIndex, 1);
    
    // 3. Hide the selector and reset the state
    hideColorSelector();

    setMessage(`You played a Wild and chose ${selectedColor.toUpperCase()}. Computer's turn...`);
    render();

    if (checkWinner()) return;

    // 4. Apply Wild Card effect
    if (card.value === "+4") {
        playPlusTwoSound(); // Use the +2 sound for the +4 effect
        setMessage(`You played a Wild +4! Computer must draw 4! New Color: ${currentColor.toUpperCase()}`);
        setTimeout(() => {
            applyPlusFourEffect(computerHand, "Computer");
        }, 500);
        return;
    }
    
    // 5. Pass turn to computer for a plain 'wild' card
    setTimeout(computerTurn, 900);
}
// ----------------------------------------------------


/* Player draws (MODIFIED) */
document.getElementById("drawBtn").onclick = () => {
  if (gameOver) return;

  // 1. Check for active +2 or +4 penalty first (+4 uses plusTwoActive flag for simplicity)
  if (plusTwoActive) {
    // Check if the penalty is from a +2 or a +4, though they draw different amounts
    const isPlusFour = topCard && topCard.value === "+4";
    const drawAmount = isPlusFour ? 4 : 2;

    for (let i = 0; i < drawAmount; i++) {
        drawCard(playerHand);
    }
    
    playDrawSound(); 
    setMessage(`You drew ${drawAmount} cards due to the +${drawAmount} penalty. Computer's turn...`);
    plusTwoActive = false; 
  } else {
    // Normal draw logic
    drawCard(playerHand);
    playDrawSound(); 
    setMessage("You drew a card. Computer's turn...");
  }
  
  render();
  // Pass the turn to the computer after the draw/penalty
  setTimeout(computerTurn, 900);
};

/* Computer turn logic (MODIFIED) */
function computerTurn() {
    if (gameOver) return;

    // 1. Check for active Skip penalty first
    if (skipActive) {
        applySkipEffect("Computer");
        return; 
    }
    
    // 2. Check for active +2 or +4 penalty
    if (plusTwoActive) {
        const isPlusFour = topCard && topCard.value === "+4";
        if (isPlusFour) {
            applyPlusFourEffect(computerHand, "Computer");
        } else {
            applyPlusTwoEffect(computerHand, "Computer");
        }
        return; 
    }
    
    // 3. Normal Turn Logic
    let playable = computerHand.find(c => canPlay(c));

    if (playable) {
        
        // --- ADDED/MODIFIED FOR WILD CARDS ---
        if (playable.isWild) {
            playWildSound(); // Play Wild sound for computer
            
            // Computer logic to choose the best color:
            // 1. Pick a color it has the most of.
            // 2. Default to the current color if it has none.
            const colorCounts = {};
            COLORS.forEach(c => colorCounts[c] = computerHand.filter(card => card.color === c && !card.isWild).length);
            
            let bestColor = 'red'; // Default just in case
            let maxCount = -1;
            
            COLORS.forEach(c => {
                if (colorCounts[c] > maxCount) {
                    maxCount = colorCounts[c];
                    bestColor = c;
                }
            });

            // Set the top card and the new current color
            topCard = playable;
            currentColor = bestColor; 

            // Remove the card
            const playedIndex = computerHand.findIndex(c => c.image === playable.image);
            computerHand.splice(playedIndex, 1);
            
            setMessage(`ðŸ¤– Computer played a Wild Card and chose ${bestColor.toUpperCase()}`);
            
            render();

            if (checkWinner()) return;

            // Apply Wild +4 effect
            if (playable.value === "+4") {
                playPlusTwoSound(); 
                setTimeout(() => {
                    applyPlusFourEffect(playerHand, "You");
                }, 500);
                return; 
            }
            
            // Plain Wild card: pass turn to player
            setTimeout(() => {
                setMessage("Your turn now!");
            }, 500);
            return; // Skip the rest of the turn logic
        }
        // ------------------------------------
        
        // Non-Wild card play
        topCard = playable;
        currentColor = playable.color; // Reset current color
        const playedIndex = computerHand.findIndex(c => c.image === playable.image);
        computerHand.splice(playedIndex, 1);
        
        playCardSound(); 

        setMessage(`ðŸ¤– Computer played ${playable.color} ${playable.value}`);
        
        render();

        if (checkWinner()) return;

        // Apply action card effects for the player
        if (playable.value === "+2") {
            plusTwoActive = true; 
            playPlusTwoSound(); 
            setTimeout(() => {
                applyPlusTwoEffect(playerHand, "You");
            }, 500);
            return; 
        } else if (playable.value === "miss") {
             skipActive = true; 
             setTimeout(() => {
                 applySkipEffect("You");
             }, 500);
             return; 
        }
        
    } else {
        // Computer draws
        drawCard(computerHand);
        playDrawSound(); 
        setMessage("ðŸ¤– Computer drew a card");
        render();
    }

    // Player's turn now.
    setTimeout(() => {
        setMessage("Your turn now!");
    }, 500);
}

/* *** Sound Effect Helpers (ADDED Wild Sound) *** */

function playWinSound() {
    MusicManager.stopMusic(); 
    const winAudio = document.getElementById('win-sound');
    if (winAudio) {
        winAudio.currentTime = 0; 
        winAudio.volume = 0.8;
        winAudio.play().catch(error => console.error("Win sound playback failed:", error));
    }
}

function playLoseSound() {
    MusicManager.stopMusic(); 
    const loseAudio = document.getElementById('lose-sound');
    if (loseAudio) {
        loseAudio.currentTime = 0; 
        loseAudio.volume = 0.8;
        loseAudio.play().catch(error => console.error("Lose sound playback failed:", error));
    }
}

function playStartSound() {
    const startAudio = document.getElementById('start-sound');
    if (startAudio) {
        startAudio.currentTime = 0;
        startAudio.volume = 0.6;
        startAudio.play().catch(error => console.warn("Start sound blocked. Needs user interaction."));
    }
}

function playCardSound() {
    const cardAudio = document.getElementById('play-card-sound');
    if (cardAudio) {
        cardAudio.currentTime = 0;
        cardAudio.volume = 0.4; 
        cardAudio.play().catch(error => console.error("Card play sound failed:", error));
    }
}

function playDrawSound() {
    const drawAudio = document.getElementById('draw-card-sound');
    if (drawAudio) {
        drawAudio.currentTime = 0;
        drawAudio.volume = 0.4; 
        drawAudio.play().catch(error => console.error("Card draw sound failed:", error));
    }
}

function playPlusTwoSound() {
    const plusTwoAudio = document.getElementById('plus-two-sound');
    if (plusTwoAudio) {
        plusTwoAudio.currentTime = 0;
        plusTwoAudio.volume = 0.7; // Higher volume for impact
        plusTwoAudio.play().catch(error => console.error("+2 sound failed:", error));
    }
}

// NEW: Function to play the Wild card sound
function playWildSound() {
    const wildAudio = document.getElementById('wild-sound');
    if (wildAudio) {
        wildAudio.currentTime = 0;
        wildAudio.volume = 0.7; // Higher volume for impact
        wildAudio.play().catch(error => console.error("Wild sound failed:", error));
    }
}


/* Winner check */
function checkWinner() {
  if (playerHand.length === 0) {
    setMessage("ðŸŽ‰ You win! Play again?");
    playWinSound(); 
    disableGame();
    return true;
  }
  if (computerHand.length === 0) {
    setMessage("ðŸ’€ Computer wins! Play again?");
    playLoseSound(); 
    disableGame();
    return true;
  }
  return false;
}

/* Disable inputs */
function disableGame() {
  gameOver = true;
  
  document.getElementById("drawBtn").disabled = true;
  
  const handDiv = document.getElementById("playerHand");
  handDiv.innerHTML = "";
  
  const button = document.createElement("button");
  button.id = "playAgainBtn";
  button.className = "bg-green-600 hover:bg-green-700 px-6 py-3 rounded text-2xl font-bold shadow-xl mt-4";
  button.innerText = "â–¶ï¸ Start New Game";
  
  button.onclick = () => {
      // Play sound before reloading
      playStartSound(); 
      // Reload the page to restart the game
      setTimeout(() => window.location.reload(), 100); 
  };
  
  handDiv.appendChild(button);
}

/* Message helper */
function setMessage(msg) {
  document.getElementById("message").innerText = msg;
}

/* ------------------------------------
      ðŸŽ¶ MUSIC MANAGER LOGIC ðŸŽ¶
------------------------------------- */

const themes = ["wonder", "voyage", "relax", "tense"];
let currentThemeIndex = -1;
let currentAudio = null;
let isMusicEnabled = false; 
const TOGGLE_BUTTON = document.getElementById('musicToggleBtn');
let rotationIntervalId = null; 

const MusicManager = {
    playNextTheme() {
        if (!isMusicEnabled) return; 
        this.stopMusic(); 
        currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        const nextThemeId = themes[currentThemeIndex] + "-theme";
        currentAudio = document.getElementById(nextThemeId);
        
        if (currentAudio) {
            currentAudio.volume = 0.5; 
            currentAudio.play().catch(error => console.error("Music playback failed:", error));
        }
    },
    
    stopMusic() {
        if (currentAudio) {
            currentAudio.pause();
            currentAudio.currentTime = 0; 
        }
    },

    startRotation() {
        if (rotationIntervalId) {
            clearInterval(rotationIntervalId);
        }
        this.playNextTheme();
        rotationIntervalId = setInterval(() => this.playNextTheme(), 60000); 
    },
    
    stopRotation() {
        if (rotationIntervalId) {
            clearInterval(rotationIntervalId);
            rotationIntervalId = null;
        }
    },

    toggleMusic() {
        isMusicEnabled = !isMusicEnabled;
        
        if (isMusicEnabled) {
            TOGGLE_BUTTON.innerText = "ðŸ”Š Music";
            this.startRotation();
        } else {
            TOGGLE_BUTTON.innerText = "ðŸ”‡ Music";
            this.stopRotation();
            this.stopMusic(); 
        }
    }
};

TOGGLE_BUTTON.addEventListener('click', () => {
    MusicManager.toggleMusic();
});


/* -------------------------------------
  START GAME FUNCTION (MODIFIED)
------------------------------------- */

function startGame() {
  generateDeck();
  playerHand = [];
  computerHand = [];
  gameOver = false; 
  plusTwoActive = false;
  skipActive = false; 
  pendingPlayIndex = -1; // Reset new state variable

  for (let i = 0; i < 5; i++) {
    drawCard(playerHand);
    drawCard(computerHand);
  }

  // Ensure the starting card is not a Wild Card. If it is, draw until it's not.
  topCard = deck.pop();
  while (topCard && topCard.isWild) {
      // Put the wild card back (or discard it for simplicity) and draw a new one
      topCard = deck.pop();
  }
  
  if (topCard) {
      currentColor = topCard.color; // Initialize the current color
  }

  render();
  setMessage("Game started! Your turn.");
}

startGame();

playStartSound();
</script>

</body>
</html>